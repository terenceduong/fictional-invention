# dear [option] outfile indir

use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
use File::Basename;
use strict;
use warnings;
use diagnostics;

use feature 'say';

use feature "switch";


my $num_args = scalar @ARGV;
say "Number of arguments $num_args";
if ($num_args != 0) {
	foreach my $arg(@ARGV) {
		say $arg;
	}
}

if ($num_args == 2) {
	# no options have been specified
} elsif ($num_args == 3) {
	# option has been specified
	if (lc $ARGV[0] eq "-g") {
		# compress with gzip
	} elsif (lc $ARGV[0] eq "-b") {
		# compress with bzip2
	} elsif (lc $ARGV[0] eq "-z") {
		# compress (WITH ZIP refer to readme.txt)
	}
}

my $orig = <STDIN>;
chomp($orig);
my $folder_name = basename($orig);
say "Folder name: $folder_name\n";
my $new = "Tempdir/" . $folder_name;

say "$orig, $new";

my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = rcopy($orig,$new);
say "$num_of_files_and_dirs, $num_of_dirs, $depth_traversed";


#!/usr/bin/perl -w
# This is a duplicate file finder.

use File::Find;
use Digest::MD5;

my %files;
my $wasted = 0;
find(\&check_file, $ARGV[0] || ".");

open(my $fh, '>', 'report.txt'); 

local $" = ", ";
my $first = 1;
foreach my $size (sort {$b <=> $a} keys %files) {
  next unless @{$files{$size}} > 1;
  my %md5;
  $first = 1;
  foreach my $file (@{$files{$size}}) {
    if ($first != 1) {
	    open(FILE, $file) or next;
	    binmode(FILE);
	    push @{$md5{Digest::MD5->new->addfile(*FILE)->hexdigest}},$file;
	    # print "\n\n-----KENFILE---\n\n $file \n\n";
	    if(defined $ARGV[1] && $ARGV[1] eq "remove-all" && $first == 0) {
	        # unlink($file);
	        print "would have removed $file\n";
	    }
	}
	$first = 0;
  }
  foreach my $hash (keys %md5) {
    next unless @{$md5{$hash}} > 1;
    print "$size: @{$md5{$hash}}\n";
    $wasted += $size * (@{$md5{$hash}} - 1);
  }
}

1 while $wasted =~ s/^([-+]?\d+)(\d{3})/$1,$2/;
print "$wasted bytes in duplicated files\n";

print $fh "My first report generated by perl\n"; 
close $fh;

sub check_file {
  -f && push @{$files{(stat(_))[7]}}, $File::Find::name;
}